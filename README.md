## 前言
这是一款根据netty开发的游戏《我的城池营垒》，下面将介绍项目的组建模块
## 核心包game-engine
游戏核心jar包game-engine为框架的基本组建，主要封装了以下功能：
- handler TCP、HTTP消息接受处理handler封装
- db 分布式数据库操作接口
- mq kafka消息收发封装
- netty TCP连接客户端，使用netty进行通信
- redis redis数据库缓存封装
- script java热更新脚本封装
- struct 通用游戏抽象实体类
- thread 游戏线程处理模型，基于线程+消息队列+线程池
- util 通用工具


通信协议

所有长链接消息通过protobuf进行消息的序列化和反序列化，具体实现可以查看game-engine项目的netty包。服务器主要分为两类消息：外部消息和内部消息
- 外部消息 外部消息为游戏客户端和网关服务器的通信，消息格式为：
  消息长度(4字节)+消息ID(4字节)+protobuf消息bytes
- 内部消息 内部消息为服务器内部消息通信转发，如网关向游戏服、大厅服转发消息,消息格式为：
  消息长度(4字节)+角色ID(8字节)+消息ID(4字节)+protobuf消息bytes

线程模型（ly写在thread）
业务线程模型主要作用是根据游戏类型进行创建，避免多线程问题，同时规避多线程加锁问题，收到客户端消息，根据消息的业务类型分配队列组（双队列），然后为队列组添加一个线程池，先进执行队列，定时读取队列的顺序优先为等待队列。如果等待队列中的任务可以获取所需加载信息，则进入线程池立即启动线程执行，否则原封不动回到等待队列。其次读取执行队列，如果还未获取游戏加载信息，则进入等待队列，如获取资源，则立即进入线程池启动线程执行

java脚本

概述


框架支持部分java代码热更新，项目中已scripts名称结尾的项目都为相应项目的脚本文件项目，如game-gate-scripts为game-gate的脚本文件。所有放在scripts项目中，并且实现IHandler接口的类都可以用于热更新，前者为服务器内部逻辑调用接口，后者为所有消息处理器调用接口。具体使用请查看game-engine项目的script包路径和game-bydr-script项目。

脚本原理

脚本为原生的java源文件，脚本更新过程为：

- 上传新的java源文件脚本类到对应服务器项目上替换老脚本
- 后台通过HTTP向服务器发送重新加载脚本命令
- 脚本引擎通过JavaCompiler编译从新编译java源文件为class类文件
- 脚本引擎通过ClassLoader从新加载新编译的类文件保存到内存中，替换之前老的Class类对象

使用注意

- 尽量让经常变动的游戏逻辑放在脚本中实现
- 确保运行环境的类加载路径下有tools.jar文件
## 公共代码game-model（kx）
该模块主要存放所有项目公共的java类文件，主要有：
- 常量定义
- 数据库实体类，DAO类
- 公共逻辑，如加载脚本，重加载配置等

目录：
- constant 常量
- db 数据库
- redis
- script
- struct（封装的其他类型）
- timer（监听状态）


## 通信消息game message
所有服务器及客户端通信的protolbuf定义文件和生成的java类
